<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>barelog: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">barelog
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">barelog Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>barelog</b> is a set of C99 modules that can be used to do some logging on many-core systems. The primary targets of barelog are the embedded heterogeneous many-core platforms (such as the <a href="https://parallella.org">Parallella platform</a>) or any core that is too small to run any Linux based OS, thus forbidding the use of traditional tools.</p>
<p>The main use-case would be the logging of some calculus-specific cores that don't have any kernel but <b>can still access a shared memory space</b> to interact with a more "traditional" host (that is to say another CPU able to run a Linux kernel).</p>
<p>Please note that due to it's current limitations, barelog is not meant to be used for serious, efficient logging/tracing. For a more sophisticated tool that provides very efficient tracing, please see also <a href="https://github.com/efficios/barectf">barectf</a>.</p>
<p>Note : in the following document, the terms "host" and "target" refer respectively to a system running a Linux kernel and able to initialize the shared memory and to the specific core that doesn't run any kernel.</p>
<p><b>Key features</b>:</p>
<ul>
<li>Entirely configurable: you have full control over the functions used by the modules to interact with the shared memory as well as the total amount of memory used by barelog (inside each core as well as in the shared section).</li>
<li>Easy to use: a simple call of the <b><a class="el" href="barelog__logger_8h.html#a3f42b27ec9aa7b19502fe9db114a39f4">barelog_log()</a></b> function (after proper initialization of the modules) allows you to log events without any further complications.</li>
<li>Provides several "functioning modes": you can enable/disable some parts of the code to suit your needs. For example, to gain some performance, you might want to disable the "DEBUG_MODE" that only offers some internal debugging functions.</li>
<li>Flush events whenever you want: a round-buffer allows you to store the events in the local memory of the logged core as long as you want before actually flushing them into the shared memory. You have full control over which stored event to actually put into the shared space.</li>
<li>Format the events data as you want: since the logging module use a modified version of "snprintf" you can store any type of data (represented as a string) in a event.</li>
</ul>
<p><b>Current limitations</b>:</p>
<ul>
<li>Pretty heavy impact on the performances: since the logging module use a modified version of "snprintf", it's quite demanding in terms of clock cycles to produce an event.</li>
<li>The size of the actual event's data is statically fixed: that means that if the events data are not full, there will be waste of both local memory (of the logged core) and shared memory.</li>
<li>The data of an event is represented by a string: which means that you can't directly access to all the data logged into that event since they are wrapped in a string.</li>
</ul>
<h2>Using</h2>
<h3>Compiling the modules</h3>
<ol type="1">
<li>You first need to edit the <b>common/include/config.h</b> file to ensure that barelog is configured to suit your needs. Note that you can directly include a custom configuration header by placing it inside the <b>platforms</b> directory and then including it.</li>
<li>Once it's done, you may want need to edit the Makefile to properly set the compiler used to compile the target module code. You can also set the TARGET_CC flag during the 'make'.</li>
<li><p class="startli">Then simply compile the modules using the provided Makefile. You can specify whether or not to use a cross-compiling toolchain by setting the CROSS_COMPILE flag. You can also decide if you rather want the resulting libraries to be static (.a) or shared (.so) by setting the HLIBTYPE and/or TLIBTYPE flags (where 'H' stands for Host and 'T' for Target). The default behavior is to produce static libraries.</p>
<p class="startli">make</p>
</li>
</ol>
<p>Or</p>
<p>make HLIBTYPE=so TLIBTYP=a</p>
<p>If everything went well, two libraries should have been produced in the <b>libs</b> folder :</p>
<ul>
<li><b>libbarelog_host</b>: targets the host program.</li>
<li><b>libbarelog_logger</b>: targets the target program.</li>
</ul>
<h3>Instrumenting and compiling your code</h3>
<h4>Instrumenting your code</h4>
<p>Once you have compiled the modules, you just need to instrument your code to get started !</p>
<p>To do that, you have to follow those steps :</p>
<ol type="1">
<li>Initialize the host: you will have to create the <b><a class="el" href="structbarelog__platform__t.html">barelog_platform_t</a></b> along with some memory management functions and to register them to the logger on the host by calling the <b><a class="el" href="barelog__host_8h.html#adc51587704401a7222bd82433c881477">barelog_host_init()</a></b> function. This will allocate all the needed chunks of shared memory according to the "config" file and initialize the all host module.</li>
<li>Initialize the target: this basically involve the same steps as above but with everything specific to the target.</li>
<li>Instrument the target code: by using a combination of the <b><a class="el" href="barelog__logger_8h.html#a3f42b27ec9aa7b19502fe9db114a39f4">barelog_log()</a></b> <b><a class="el" href="barelog__logger_8h.html#a4e17f1118b4323a4713ad3fd44029ad6">barelog_flush()</a></b> and <b><a class="el" href="barelog__logger_8h.html#a35151c45dc22a94d4ef0b1e8d8da34d7">barelog_clean()</a></b>, you should be able to produce and manage the events inside the logged core.</li>
<li>Retrieve the events on the host: the host API offers some functions to extract and display the logged events (please see the given example).</li>
<li>Finalize the logger: once you're done logging around, use the **barelog_finalize() function to ensure every resource is correctly deallocated.</li>
</ol>
<p>Please refer to the documentation and/or the given example for more informations.</p>
<p><b>WARNING</b> : if you use barelog, some part of the shared memory (beginning at the given platform's mem_space) will be used by it. To avoid every hazardous behavior, consider using the <b>BARELOG_SHARED_MEM_MAX</b> macro (which give the size (in bytes) of the memory taken by barelog) when allocating new chunks of memory for your personal needs.</p>
<h4>Compiling your code</h4>
<p>Now that we have everything ready, we just need to compile our programs (one running on the host and the other on the target).</p>
<p>First of all, make sure that the previously generated barelog's libraries can be found by the compiler/linker. Assuming that your using gcc, you just need to specify the -L option : </p><pre class="fragment">gcc -L path/to/libraries/
</pre><p>You will then have to build the host program using the <b>libbarelog_host</b> library and the target program with the <b>libbarelog_logger</b> library : </p><pre class="fragment">gcc -L path/to/libraries/ target_main.c -lbarelog_logger
gcc -L path/to/libraries/ host_main.c -lbarelog_host
</pre><p>Of course, this need to be adapted in case you need to use another compiler.</p>
<h3>Create your own configuration file</h3>
<p>To create you own configuration file, you can simply follow the "template" given by <b>common/include/config.h</b>. You don't have to fulfill every fields since there already is some default values (please refer to config.h).</p>
<p>Once it's done, you just have to put it in the <b>platforms</b> directory, thus guaranteeing that you could later include it in the config header.</p>
<h3>Warnings</h3>
<ul>
<li>The core numbering on the target must begin at 0.</li>
<li>The barelog_device_mem_manager module should be placed in the local memory of each logged core.</li>
<li>The "SAFE" mode, providing shared memory synchronization mechanism is still to be tested, thus implying that no guarantee can be provided.</li>
</ul>
<h2>Configuring new behaviors/functionalities</h2>
<p>You might want to add some functionalities that need some data stored into the shared memory space of barelog. Since this space is strictly ordered, you will have to follow those steps to ensure the good global behavior of the modules :</p>
<ol type="1">
<li>Define the size taken by those data inside the <b><a class="el" href="barelog__internal_8h.html" title="Module defining the internal configurations of barelog. ">barelog_internal.h</a></b> file: you can use the following naming convention : 'BARELOG_FUNCNAME_MEM_SIZE'</li>
<li>Edit the BARELOG_SHARED_MEM_DATA_OFFSET macro to take the new data in account while computing the offsets of each barelog's data inside the shared memory.</li>
<li>Reserve a new mem_space for your data by adding '1' to the BARELOG_HOST_NB_MEM_SPACE macro.</li>
<li>Define the new index inside the host's mem_space table of the new data: you can use the following naming convention : 'BARELOG_FUNCNAME_I'. Please be careful with the index since some may already have been taken and the BARELOG_NB_CORES first refer to the actual events reserved memory spaces. You can follow what has been done with BARELOG_DEBUG_MODE and BARELOG_SAFE_MODE to get the global picture of how to do it.</li>
</ol>
<ol type="1">
<li>Modify the behavior of the "host_mem_manager_init()" and "host_mem_manager_finalize()" functions to respectively init and finalize the newly reserved mem_space. </li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Nov 25 2015 15:31:26 for barelog by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
